[{"categories":["python"],"content":"使用python的ftplib进行ftp操作，是python3的标准库，不需要安装。 import ftplib import logging import os class FTPClient(): sep = \"/\" def __init__(self, ip, port, username, password): self.ip = ip self.port = port self.username = username self.password = password self.ftp = ftplib.FTP() self.ftp.connect(self.ip, self.port) self.ftp.login(self.username, self.password) self.ftp.encoding = \"UTF-8\" def download(self, path, filename, local_path): \"\"\" 从FTP服务器下载文件到本地 参数： path (str): 文件所在路径 filename (str): 文件名 local_path (str): 本地保存路径 返回： 无 \"\"\" remote_filename = self.join(path, filename) self.ftp.retrbinary('RETR ' + remote_filename, open(os.path.join(local_path, os.path.basename(remote_filename)), 'wb').write) def listdir_recursive(self, path): # 递归地列出指定路径下的所有文件和文件夹的名称 filenames = self.listdir(path) files = [] for filename in filenames: fullname = self.join(path, filename) if self.is_file(fullname): files.append(fullname) elif self.is_directory(fullname): t_files = self.listdir_recursive(fullname) files.extend(t_files) else: logging.error(\"unkown ftp path: %s\", fullname) return files def listdir(self, remote_path): # 列出路径下的文件和文件夹，非递归 self.ftp.cwd(remote_path) return self.ftp.nlst() def is_directory(self, path): \"\"\" 判断给定路径是否为目录 参数： path：要判断的路径 返回值：True or False \"\"\" try: results = self.ftp.nlst(path) if len(results) \u003e 1: return True elif len(results) == 1: return path not in results except: pass return False def is_file(self, path): \"\"\" 判断给定路径是否是一个文件 :param path: 文件路径 :return: 若给定路径是一个文件则返回True，否则返回False \"\"\" try: self.ftp.size(path) return True except: pass return False @classmethod def join(cls, *paths): \"\"\" 将多个路径拼接成一个路径。 :param paths: 多个路径，可以为空 :type paths: str :return: 拼接后的路径 :rtype: str \"\"\" if len(paths) == 0: return \"\" new_path = paths[0] for i in range(1, len(paths)): if not new_path.endswith(cls.sep): new_path += cls.sep new_path += paths[i] return new_path def close(self): \"\"\" 关闭FTP连接 :return: None \"\"\" self.ftp.quit() ","date":"2023-12-01","objectID":"/posts/python-ftplib-20231201/:0:0","tags":["python","ftp","ftplib"],"title":"python ftp客户端使用 ftplib","uri":"/posts/python-ftplib-20231201/"},{"categories":["java"],"content":"本文主要集中在实践上，将在代码层面上讲述如何获取证书链并解析证书中的信息。本文不会过多的讲解数字证书的一些理论和细节，只会点到即止。 ","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:0:0","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":["java"],"content":"java获取域名的证书链 String domain = \"nti.nsfocus.com\"; URL url = new URL(\"https://\" + domain); HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(); // connection.setSSLSocketFactory(trustSelfSignedSSLSockFactory); // connection.setHostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); //connection.setConnectTimeout(getTimeout() * 1000); //connection.setReadTimeout(getReadTimeout() * 1000); connection.connect(); Certificate[] certificates = connection.getServerCertificates(); 如上所示就可以获取到nti.nsfocus.com的证书链，获取到的证书链第一个证书是网站网站的证书，后面的是CA的证书。获取到的顺序和下图正好是相反的，下图是nti.nsfocus.com的证书路径，最下面是*.nsfocus.com的证书，中间是*.nsfocus.com的办法机构的证书，第一个是root证书，root证书签发了RapidSSL的证书，也就是图中的第二个证书。 java获取一个网站的证书过程和浏览器访问一个网站类似，会对网站证书进行合规性检查。比如这个网站的证书是否符合证书声明的dns域，或者证书是否过期。 下述代码声明了不检查证书的dns域是否合规。 connection.setHostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); // \u003cdependency\u003e // \u003cgroupId\u003eorg.apache.httpcomponents\u003c/groupId\u003e // \u003cartifactId\u003ehttpclient\u003c/artifactId\u003e // \u003cversion\u003e4.5.12\u003c/version\u003e // \u003c/dependency\u003e 比如nti.nsfocus.com的证书dns域为*.nsfocus.com，表示所有nsfocus.com的子域名均可以使用。但是如果nsfocus.com.cn也是用这个域名chrome就会报警，同样我们上述的java代码也会抛出异常。 同样，除了dns域的检查，java代码也会对证书的合法性进行验证，比如是不是可信CA签发的证书，是不是已经过期，不合法的情况也会抛出异常。下述代码可以让代码不进行这种检查，就是让代码接受所有的证书，无论是可信机构签发的证书，还是自签的证书，或者已经过期的证书，都会认为合法。 import javax.net.ssl.*; import java.security.GeneralSecurityException; private static SSLSocketFactory getTrustSelfSignedSSLSockFactory() { TrustManager[] trustAllCerts = new TrustManager[]{ new X509TrustManager() { public java.security.cert.X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } public void checkClientTrusted( java.security.cert.X509Certificate[] certs, String authType) { } public void checkServerTrusted( java.security.cert.X509Certificate[] certs, String authType) { } } }; // Install the all-trusting trust manager try { SSLContext sc = SSLContext.getInstance(\"SSL\"); sc.init(null, trustAllCerts, new java.security.SecureRandom()); return sc.getSocketFactory(); } catch (GeneralSecurityException ignored) { } return null; } private static SSLSocketFactory trustSelfSignedSSLSockFactory = getTrustSelfSignedSSLSockFactory(); connection.setSSLSocketFactory(trustSelfSignedSSLSockFactory); ","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:1:0","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":["java"],"content":"提取转化数字证书中的信息 ","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:2:0","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":["java"],"content":"信息提取 java.security.cert.X509Certificate是java提供的证书类，我们使用上述代码获取的到的Certificate对象可以直接转换成该对象 X509Certificate certificate = (X509Certificate) cert; 获取到这个X509Certificate对象后就可以利用他提供的解析方法提取其中的信息。X509Certificate提供了很多get方法来获取其中的信息， X509Certificate certificate = (X509Certificate) cert;\r// 获取证书的生效时间和过期时间\rcertificate.getNotBefore();\rcertificate.getNotAfter();\r// 数字证书的版本\rcertificate.getVersion();\r// 证书的公钥\rPublicKey publicKey = certificate.getPublicKey();\r// 证书使用者的信息\rX500Principal subjectX500Principal = certificate.getSubjectX500Principal()；\r// 证书颁发者的信息\rX500Principal issuerX500Principal = certificate.getIssuerX500Principal();\r// subject alternative names 使用者可选名称，dns域就在其中\rcertificate.getSubjectAlternativeNames();\r// 证书的编号，编号应以16进制进行编码，不舍弃前缀0。直接getSerialNumber()是一个大整数\rbyte2Hex(certificate.getSerialNumber().toByteArray());\r","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:2:1","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":["java"],"content":"证书颁发者和使用者的X500Principal数据解析。 LdapName ldapDN = null;\rtry {\rldapDN = new LdapName(x500Principal.getName());\r} catch (InvalidNameException e) {\rreturn null;\r}\rfor (Rdn rdn : ldapDN.getRdns()) {\rswitch (rdn.getType()) {\rcase \"C\":\r// C表示country code，是国家的两个字母的缩写，比如中国是CN。注意：港澳台可能会编码成HK等省份名字，注意合规性检查。\rbreak;\rcase \"ST\":\r// ST表示StateOrProvinceName 省份或者州的名字\rbreak;\rcase \"L\":\r// L表示locality，地区，表示城市级的名字\rbreak;\rcase \"O\":\r// organization，组织名称\rbreak;\rcase \"OU\":\r// 组织中的哪个单位，一般没有，但是大公司会有，比如百度证书中OU为service operation department\rbreak;\rcase \"CN\":\r// common name，通用名称。一般为网站的域名。\rbreak;\rdefault:\r// log.error(\"unknown subject rdn type {}\", rdn.getType());\r}\r}\r","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:2:2","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":["java"],"content":"使用者可选名称的解析。 Collection\u003cList\u003c?\u003e\u003e alternativeNames = certificate.getSubjectAlternativeNames();\rfor (List\u003c?\u003e name : alternativeNames) {\r// name 是 [one, two]这种形式，one是key，two是value\rif (\"2\".equals(String.valueOf(name.get(0)))) {\r// 2 表示dns, source code里面有解说\rString value = String.valueOf(name.get(1));\r// value就是dns域的其中一个值\r}\r}\r","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:2:3","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":["java"],"content":"证书的指纹 windows平台展示证书信息中的指纹其实是证书sha1哈希值。除了sha1，其他哈希都可以算出来。计算证书的哈希要对其字节数组进行计算才可以。 byte[] certEncode = certificate.getEncoded();\r对certEncode进行相应的哈希计算就可以得到证书的其他哈希值。 ","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:2:4","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":["java"],"content":"证书base64编码保存和解码 // java.util.Base64\rpublic String encodeCertificate(Certificate certificate) {\rtry {\rreturn new String(Base64.getEncoder().encode(certificate.getEncoded()));\r} catch (CertificateEncodingException ignored) {\r}\rreturn null;\r}\rpublic X509Certificate decodeCertificate(String certificate) {\rif (!isValid(certificate)) {\rreturn null;\r}\rtry {\r// java.security.cert.CertificateFactory\rCertificateFactory fact = CertificateFactory.getInstance(\"X.509\");\r// fact.generateCertificate(new ByteArrayInputStream(Base64.getDecoder().decode(cert.getBytes())));\rreturn (X509Certificate) fact.generateCertificate(new ByteArrayInputStream(Base64.getDecoder().decode(certificate)));\r} catch (CertificateException e) {\re.printStackTrace();\r}\rreturn null;\r}\r","date":"2021-02-15","objectID":"/posts/certifcate-java-get-and-convert/:2:5","tags":["java","数字证书"],"title":"java获取网站的证书链和证书信息解析转换","uri":"/posts/certifcate-java-get-and-convert/"},{"categories":null,"content":"关于本站 本站是一个个人博客网站，用于博主分享一些技术文章。 ","date":"2021-02-15","objectID":"/about/:1:0","tags":null,"title":"关于本站点","uri":"/about/"},{"categories":null,"content":"联系方式 暂无 ","date":"2021-02-15","objectID":"/about/:2:0","tags":null,"title":"关于本站点","uri":"/about/"}]